<?php

/**
 * TDO NOT EDIT this file, EXTEND it!
 *
 * Description
 *      This shell is designed to process data
 *      updates for agency deployments.
 *
 * Instructions
 *      1.  Create a new shell file.
 *      2.  At the top of the new file include this file.
 *      3.  Make sure you're new class extends this class.
 *      4.  Add the necessary models to $uses variable.
 *
 *      5.  Create public method queryForRecords().
 *      6.  Add your custom query logic and return the data.
 *
 *      7.  Create public method processRecord().
 *      8.  Add your custom processing logic and return SQL statements.
 *
 *      9.  Run your extended shell to produce the new SQL file.
 *      10. Copy the new SQL file to the app/Console repository and commit.
 *
 * What This Shell Does
 *      1.  Check for sql file and run it.
 *      2.  Query for records that need processed.
 *      3.  Build sql statements.
 *      4.  Create the sql file if needed and add/append statements.
 *      5.  Run sql statements on the database.
 *
 * Shell/SQL File locations
 *      /app/Console/Command/YourExtendedShell.php
 *      /app/Console/Command/YourExtendedShell.sql
 */

app::uses('Sanitize', 'Utility');

/**
 * DataFixParentShell
 *
 * @package    App
 * @subpackage App.Console.Command
 * @author     Iowa Interactive, LLC.
 */
class DataFixParentShell extends AppShell
{
    /**
     * load cake models
     */
    public $uses = array(
        'Model',
        //'Plugin.ModelName',
    );

    /**
     * php script memory limit setting
     * in megabytes
     */
    public $mem_limit = '128';

    /**
     * mysql buffer length and allowed packet sizes
     * in megabytes
     */
    public $mysql_buffer_length = 1;
    public $mysql_packet_size = 100;

    /**
     * max number of sql statements to process at one time
     */
    public $max_statements = 5000;

    /**
     * file line ending
     */
    public $line_ending = PHP_EOL;

    /**
     * SQL file settings
     *
     * leave these setting empty. These settings
     * are automatically set in the init function.
     */
    public $sql_file_name = '';
    public $sql_file_location = '';

    /**
     * SQL statements
     */
    private $sql_statements = array(
        'count' => 0,
        'sql' => ''
    );



    /* Primary funcitons ---------------------------------------------- */

    /**
     * main method
     *
     * @return void
     * @access public
     */
    public function main()
    {
        try
        {
            // initialize the shell
            $this->out('Initializing Shell');
            $this->init();

            // run SQL file first
            // if the file has been generated once already this will
            // save us from having to process those records again
            $this->out('Run SQL File');
            $this->runSqlFile();

            // get records
            // make sure your query excludes records that have already
            // been processed.
            $this->out('Query for Data');
            $records = $this->queryForRecords();

            // did we find any records to run?
            if (! count($records))
            {
                // set the message for console output
                $this->out('No records to process. Exit shell.');

                // exit w/ status 0
                // status 0 won't fail Jenkins job
                exit(0);
            }

            $this->out(sprintf('Found %s records to process.', count($records)));

            // loop the records
            $this->out('Processing Records');
            foreach ($records as $record)
            {
                // process the query record and return array of
                // statements to run for this query record
                $statements = $this->processRecord($record);

                // did we get any statements?
                if (! count($statements))
                {
                    // skip to the next record
                    continue;
                }

                // loop the statements
                foreach ($statements as $statement)
                {
                    // add the statement to the sql string
                    $this->sql_statements['sql'] .= $statement . $this->line_ending;

                    // increment the statement count
                    $this->sql_statements['count']++;
                }

                // are we at or above our max count?
                if ($this->sql_statements['count'] >= $this->max_statements)
                {
                    // run and write the SQL
                    // this also empties the sql string and
                    // resets the statement count
                    $this->out('Updating Database');
                    $this->sqlRunWrite();
                }
            }

            // we've run out of records to process but there
            // may be some statements that still need to run
            // and be written to the SQL file
            if ($this->sql_statements['count'] > 0)
            {
                $this->out('Updating Database');
                $this->sqlRunWrite();
            }
        }
        catch (Exception $e)
        {
            // debug the error
            $this->out($e->getMessage() . ' Exit shell.');

            // exit w/ status 1
            // status 1 will fail Jenkins job
            exit(1);
        }

        // our process is complete
        $this->out('Process complete. Have a nice day!');
    }

    /**
     * run query to get records that need to be processed
     *
     * here is where you define the query and get your query
     * records. Make sure the query excludes records that
     * have already been processed or don't need to be
     * processed. This is very important.
     *
     * you can write you're own query
     *      $query = 'SELECT * FROM TABLE WHERE FIELD="value";';
     *      return $this->Model->query($query);
     *
     * or you can use CakePHP query options
     *      $query_options = array('conditions' => array());
     *      return $this->YourModel->find('all', $query_options);
     *
     * if you use CakePHP you need to add YourModel to the
     * $uses array near the top of the page
     *
     * @return array
     * @access public
     */
    public function queryForRecords ()
    {
        $this->out('Overwrite the queryForRecords() method in your extended class.'); exit();
    }

    /**
     * process query records and return SQL statements
     *
     * here is where you do all of your process logic to manipulate
     * the data and return SQL statements to be run by this shell as
     * well as by the SQL file later.
     *
     * examples of return array
     *      simple update (one record, one statement)
     *          return array('UPDATE TABLE SET FIELD="VALUE" WHERE ID=123 LIMIT 1;')
     *
     *      complex update (one record, multiple statements)
     *          return array(
     *              'UPDATE TABLE SET FIELD="VALUE" WHERE ID=123 LIMIT 1;',
     *              'DELETE TABLE_2 WHERE ID=456 LIMIT 1;'
     *          )
     *
     * @param array $record single record set from query records
     *
     * @return array
     * @access public
     */
    public function processRecord ($record = null)
    {
        $this->out('Overwrite the processRecord() method in your extended class.'); exit();
    }



    /* Secondary funcitons ---------------------------------------------- */

    /**
     * shell initialization funciton
     *
     * @return void
     * @access private
     */
    private function init ()
    {
        // set the memory limit
        if ($this->mem_limit)
        {
            ini_set('memory_limit', $this->mem_limit . 'M');
        }

        // tell Model not to look for a table
        $this->Model->useTable = false;

        // set mysql buffer length
        /*
        if ($this->mysql_buffer_length)
        {
            $this->Model->query(
                sprintf(
                    'set global net_buffer_length=%s;',
                    ($this->mysql_buffer_length * 1024 * 1024)
                )
            );
        }

        // set mysql packet size
        if ($this->mysql_packet_size)
        {
            $this->Model->query(
                sprintf(
                    'set global max_allowed_packet=%s;',
                    ($this->mysql_packet_size * 1024 * 1024)
                )
            );
        }
        */

        // combine the SQL file name and shell directory path
        $this->sql_file_location = sprintf('%s/%s.sql', dirname(__FILE__), preg_replace('/Shell/', '', get_class($this)));
    }

    /**
     * run SQL file method
     *
     * @return void
     * @access private
     */
    private function runSqlFile ()
    {
        try
        {
            // is there a file run?
            if (! file_exists($this->sql_file_location))
            {
                $this->out('No SQL file to run.');
                return;
            }

            // get the default databse creds
            $db_config = get_class_vars('DATABASE_CONFIG');
            $db_config = $db_config['default'];

            // format the mysql command
            $cmd = sprintf(
                'mysql -h%s -u%s -p%s %s < %s',
                $db_config['host'],
                $db_config['login'],
                $db_config['password'],
                $db_config['database'],
                $this->sql_file_location
            );
            //echo($cmd); exit();

            // attempt to run SQL
            exec($cmd);
        }
        catch (Exception $e)
        {
            throw $e;
        }
    }

    /**
     * run/write collected SQL method
     *
     * @return void
     * @access private
     */
    private function sqlRunWrite ()
    {
        try
        {
            // are there any sql statements to run?
            if ($this->sql_statements['count'])
            {
                // attempt to run the statements first
                // we don't won't to write to the file if the statements don't work
                try
                {
                    $this->Model->query($this->sql_statements['sql']);
                }
                catch (Exception $e)
                {
                    print_r($this->sql_statements['sql']);
                    throw $e;
                }

                // open the SQL file
                // "a" = Open for writing only; place the file pointer at
                // the end of the file. If the file does not exist, attempt
                // to create it.
                if (! $handle = fopen($this->sql_file_location, "a"))
                {
                    throw new Exception (sprintf('Failed to open SQL file - %s.', $this->sql_file_location));
                }

                // attempt to write the statements
                if (! fwrite($handle, $this->sql_statements['sql']))
                {
                    throw new Exception ('Failed to write SQL to file.');
                }

                // close SQL file
                if (is_resource($handle))
                {
                    fclose($handle);
                }

                // zero out the count and SQL statements
                $this->sql_statements = array(
                    'count' => 0,
                    'sql' => ''
                );
            }
        }
        catch (Exception $e)
        {
            throw $e;
        }
    }
}
